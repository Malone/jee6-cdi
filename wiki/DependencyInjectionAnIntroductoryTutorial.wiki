#summary Dependency Injection - An Introductory Tutorial
#sidebar TOCArticlesDependencyInjectionAnIntroductoryTutorial

<h1> Dependency Injection - An Introductory Tutorial </h1>


<wiki:toc max_depth="5" />


= Introduction =

This article discusses dependency injection in a tutorial format. It covers some of the features of CDI such as type safe annotations configuration, alternatives and more. 

[http://jcp.org/aboutJava/communityprocess/final/jsr299/index.html CDI] is the Java standard for dependency injection and interception (AOP). It is evident from the popularity of DI and AOP that Java needs to address DI and AOP so that it can build other standards on top of it. DI and AOP are the foundation of many Java frameworks.

CDI is a foundational aspect of Java EE 6. It is or will be shortly supported by Caucho's Resin, IBM's !WebSphere, Oracle's Glassfish, Red Hat's JBoss and many more application servers. CDI is similar to core Spring and Guice frameworks. Like JPA did for ORM, CDI simplifies and sanitizes the API for DI and AOP. If you have worked with Spring or Guice, you find CDI easy to use and easy to learn.

It is no accident that this tutorial follows this tutorial [http://java.dzone.com/articles/dependency-injection-an-introd (using Spring "new" DI annotations)] written three years ago. It will be interesting to compare and contrast the examples in this tutorial with the one written three years ago for Spring DI annotations.


= Dependency Injection =

Dependency Injection (DI) refers to the process of supplying an external dependency to a software component. DI can help make your code architecturally pure. It aids in design by interface as well as test-driven development by providing a consistent way to inject dependencies. For example, a data access object (DAO) may depend on a database connection. Instead of looking up the database connection with JNDI, you could inject it. 

One way to think about a DI framework like CDI is to think of JNDI turned inside out. Instead of an object looking up other objects that it needs to get its job done (dependencies), a DI container injects those dependent objects. This is the so-called Hollywood Principle, “Don't call us” (lookup objects), “we’ll call you” (inject objects). 

If you have worked with CRC cards you can think of a dependency as a collaborator, i.e., an object that another object needs to perform its role.
 
==Dependency Injection-`AutomatedTellerMachine` without CDI or Spring or Guice==

Let's say that you have an automated teller machine (ATM, also known as an automated banking machine in other countries) and it needs the ability to talk to a bank. It uses what it calls a transport object to do this. In this example, a transport object handles the low-level communication to the bank. 

This example could be represented by these two interfaces as follows: 

====Code Listing: `AutomatedTellerMachine` interface====

{{{
package org.cdi.advocacy;

import java.math.BigDecimal;

public interface AutomatedTellerMachine {

	public abstract void deposit(BigDecimal bd);

	public abstract void withdraw(BigDecimal bd);

}
}}}

====Code Listing: ATMTransport interface====
{{{
package org.cdi.advocacy;

public interface ATMTransport {
	public void communicateWithBank(byte[] datapacket);
}
}}}

Now the *`AutomatedTellerMachine`* needs a transport to perform its intent, namely withdraw money and deposit money. To carry out these tasks, the *`AutomatedTellerMachine`* may depend on many objects and collaborates with its dependencies to complete the work. 

An implementation of the *`AutomatedTellerMachine`* may look like this:

====Code Listing: AutomatedTellerMachineImpl class====
{{{
package org.cdi.advocacy;
...
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	private ATMTransport transport;
	
        ...
	public void deposit(BigDecimal bd) {
		System.out.println("deposit called");
		transport.communicateWithBank(...);
	}

	public void withdraw(BigDecimal bd) {
		System.out.println("withdraw called");
		transport.communicateWithBank(...);
	}

}

}}}

The *`AutomatedTellerMachineImpl`* does not know or care how the transport withdraws and deposits money from the bank. This level of indirection allows us to replace the transport with different implementations such as in the following example:

===Three example transports: `SoapAtmTransport`, `StandardAtmTransport` and `JsonAtmTransport`===

====Code Listing: `StandardAtmTransport`====
{{{
package org.cdi.advocacy;


public class StandardAtmTransport implements ATMTransport {

	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via Standard transport");
                ...
	}

}
}}}

====Code Listing: `SoapAtmTransport`====
{{{
package org.cdi.advocacy;

public class SoapAtmTransport implements ATMTransport {

	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via Soap transport");
                ...
	}

}

}}}


====Code Listing: `JsonRestAtmTransport`====
{{{
package org.cdi.advocacy;

public class JsonRestAtmTransport implements ATMTransport {

	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via JSON REST transport");
	}

}
}}}

Notice the possible implementations of the *`ATMTransport interface`*. The `*AutomatedTellerMachineImpl*` does not know or care which transport it uses. Also, for testing and developing, instead of talking to a real bank, you could easily use Mockito or EasyMock or you could even write a *`SimulationAtmTransport`*.


The concept of DI transcends CDI, Guice and Spring. Thus, you can accomplish DI without CDI or Spring as follows: 

====Code Listing: `AtmMain`: DI without CDI, Spring or Guice====

{{{
package org.cdi.advocacy;

public class AtmMain {
        
        public void main (String[] args) {
                AutomatedTellerMachine atm = new AutomatedTellerMachineImpl();
                ATMTransport transport = new SoapAtmTransport();
                /* Inject the transport. */           
                ((AutomatedTellerMachineImpl)atm).setTransport(transport);
                
                atm.withdraw(new BigDecimal("10.00"));
                
                atm.deposit(new BigDecimal("100.00"));
        }

}
}}}

Then injecting a different *transport* is a mere matter of calling a different setter method as follows:

====Code Listing: `AtmMain`: DI without CDI, Spring or Guice: `setTransport`====
{{{
ATMTransport transport = new SimulationAtmTransport();
((AutomatedTellerMachineImpl)atm).setTransport(transport);
}}}


The above assumes we added a *`setTransport`* method to the *`AutomateTellerMachineImpl`*. Note you could just as easily use constructor arguments instead of a setter method. Thus keeping the interface of your *`AutomateTellerMachineImpl`* clean.

==Dependency Injection-`AutomatedTellerMachine` using CDI==


To use CDI to manage the dependencies you could do the following:
 # Create an empty *bean.xml* file under *META-INF* resource folder
 # Use the *@Inject* annotation to annotate a *`setTransport`* setter method in *`AutomatedTellerMachineImpl`*
 # Use the *@Default* annotation to annotate the *`StandardAtmTransport`*
 # Use the *@Alternative* to annotate the *`SoapAtmTransport`*, and *`JsonRestAtmTransport`*.
 # Use the *@Named* annotation to make the *`AutomatedTellerMachineImpl`* easy to look up; give it the name "atm"
 # Use the CDI *`beanContainer`* to look the *atm*, makes some deposits and withdraws.


===Step 1: Create an empty *bean.xml* file under *META-INF* resource folder ===
===META-INF/beans.xml===

CDI needs an bean.xml file to be in META-INF of your jar file or classpath or WEB-INF of your web application. This file can be completely empty (as in 0 bytes). If there is no beans.xml file in your META-INF or WEB-INF then that war file or jar file will not be processed by CDI. Otherwise, CDI will scan the jar and war file if the beans.xml file exists even if it is 0 bytes.

==== Code Listing: `META-INF/beans.xml` just as empty as can be====

{{{
<beans xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
http://java.sun.com/xml/ns/javaee
http://java.sun.com/xml/ns/javaee/beans_1_0.xsd">

</beans>
}}}

Notice that we included a starter beans.xml file with a namespace and a `<beans>` element. Although *beans.xml* could be completely empty, it is nice to have a starter file so when you need to add things (like later on in this tutorial) you can readily. Also it keeps the IDE from complaining about ill formed xml when you actually do have a 0 byte beans.xml. (I hate when the IDE complains. It is very distracting.)


===Step 2: Use the *@Inject* annotation to annotate a *`setTransport`* setter method in *`AutomatedTellerMachineImpl`*===

The *@Inject* annotation is used to mark where an injection goes. You can annotate constructor arguments, instance fields and setter methods of properties. In this example, we will annotate the *setTransport* method (which would be the setter method of the transport property).

====Code Listing: `AutomatedTellerMachineImpl` using *@Inject* to inject a transport====

{{{
package org.cdi.advocacy;

...

import javax.inject.Inject;

public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	private ATMTransport transport;

	@Inject
	public void setTransport(ATMTransport transport) {
		this.transport = transport;
	}

       ...

}

}}}

By default, CDI would look for a class that implements the *`ATMTransport`* interface, once it finds this it creates an instance and injects this instance of *`ATMTransport`* using the setter method *`setTransport`*. If we only had one possible instance of *`ATMTransport`* in our classpath, we would not need to annotate any of the *`ATMTransport`* implementations. Since we have three, namely, *`StandardAtmTransport`*, *`SoapAtmTransport`*,  and *`JsonAtmTransport`*, we need to mark two of them as *`@Alternative`*s and one as *`@Default`*.

===Step 3: Use the *@Default* annotation to annotate the *`StandardAtmTransport`*===

At this stage of the example, we would like our default transport to be *`StandardAtmTransport`*; thus, we mark it as *`@Default`* as follows:.

==== Code Listing: `StandardAtmTransport` using *@Default*====
{{{
package org.cdi.advocacy;

import javax.enterprise.inject.Default;

@Default
public class StandardAtmTransport implements ATMTransport {
    ...

}}}

It should be noted that a class is @Default by default. Thus marking it so is redundant; and not only that its redundant. 

=== Step 4: Use the *@Alternative* to annotate the *`SoapAtmTransport`*, and *`JsonRestAtmTransport`*. ===

If we don't mark the others as @Alternative, they are by default as far as CDI is concerned, marked as @Default.  Let's mark *`JsonRestAtmTransport`* and *`SoapRestAtmTransport`* *@Alternative* so CDI does not get confused.

==== Code Listing: `JsonRestAtmTransport` using *@Alternative*====
{{{
package org.cdi.advocacy;

import javax.enterprise.inject.Alternative;

@Alternative
public class JsonRestAtmTransport implements ATMTransport {

...
}

}}}

==== Code Listing: `SoapAtmTransport` using *@Alternative*====
{{{
package org.cdi.advocacy;

import javax.enterprise.inject.Alternative;

@Alternative
public class SoapAtmTransport implements ATMTransport {
   ...
}

}}}


 === Step 5: Use the *@Named* annotation to make the *`AutomatedTellerMachineImpl`* easy to look up; give it the name "atm"===

Since we are not using `AutomatedTellerMachineImpl` from a Java EE 6 application, let's just use the *`beanContainer`* to look it up. Let's give it an easy logical name like "atm". To give it a name, use the @Named annotation. The @Named annotation is also used by JEE 6 application to make the bean accessible via the Universal EL (EL stands for Expression language and it gets used by JSPs and JSF components).

Here is an example of using @Named to give the *`AutomatedTellerMachineImpl`* the name "atm"as follows:

==== Code Listing: `AutomatedTellerMachineImpl` using *@Named*====
{{{
package org.cdi.advocacy;

import java.math.BigDecimal;

import javax.inject.Inject;
import javax.inject.Named;

@Named("atm")
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
       ...

}
}}}



=== Step 6: Use the CDI *`beanContainer`* to look up the *atm*, makes some deposits and withdraws. ===

Lastly we want to look up the *atm* using the *`beanContainer`* and make some deposits.
 
==== Code Listing: `AtmMain` looking up the atm ====
{{{
package org.cdi.advocacy;

...

public class AtmMain {

        ...
        ...

	public static void main(String[] args) throws Exception {
		AutomatedTellerMachine atm = (AutomatedTellerMachine) beanContainer
				.getBeanByName("atm");

		atm.deposit(new BigDecimal("1.00"));

	}

}
}}}

When you run it from the command line, you should get the following:

{{{
deposit called
communicating with bank via Standard transport
}}}

If you remove the *@Default* from the *`StandardATMTransport`*, you will get the same output.
If you remove the *@Alternative* from both of the other transports, namely,  *`JsonATMTransport`*, and  *`SoapATMTransport`*, CDI will croak as follows:

{{{
Exception in thread "main" java.lang.ExceptionInInitializerError
Caused by: javax.enterprise.inject.AmbiguousResolutionException: org.cdi.advocacy.AutomatedTellerMachineImpl.setTransport: 
Too many beans match, because they all have equal precedence.  
See the @Stereotype and <enable> tags to choose a precedence.  Beans:
    ManagedBeanImpl[JsonRestAtmTransport, {@Default(), @Any()}]
    ManagedBeanImpl[SoapAtmTransport, {@Default(), @Any()}]
    ManagedBeanImpl[StandardAtmTransport, {@javax.enterprise.inject.Default(), @Any()}]
   ...
}}} 

==Using @Inject to inject via constructor args and fields==
TBD Under construction

Field injection.
{{{
...
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject
	private ATMTransport transport;

}}}

Constructor injection.
{{{
...
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject 
	public AutomatedTellerMachineImpl(ATMTransport transport) {
		this.transport = transport;
	}

}}}

==Using simple @Produces==
Under Construction....

Simple producer

{{{
package org.cdi.advocacy;

import javax.enterprise.inject.Produces;

public class TransportFactory {
		
	@Produces ATMTransport createTransport() {
		System.out.println("ATMTransport created with producer");
		return new StandardAtmTransport();
	}

}
}}}

ATM machine code to receive simplr producer

{{{
import javax.inject.Inject;
import javax.inject.Named;

@Named("atm")
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject
	private ATMTransport transport;
        ...
}}}

Output
{{{
ATMTransport created with producer
deposit called
communicating with bank via Standard transport
}}}



==Using @Alternative to select an Alternative==
TBD under construction

/META-INF/beans.xml
{{{
<beans xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
http://java.sun.com/xml/ns/javaee
http://java.sun.com/xml/ns/javaee/beans_1_0.xsd">
	<alternatives>
		<class>org.cdi.advocacy.JsonRestAtmTransport</class>
	</alternatives>
</beans>
}}}

Output
{{{
deposit called
communicating with bank via JSON REST transport
}}}



==Using @Qualifier to inject different types==
TBD

Soap Qualifier
{{{
package org.cdi.advocacy;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.*;

import javax.inject.Qualifier;


@Qualifier @Retention(RUNTIME) @Target({TYPE, METHOD, FIELD, PARAMETER})
public @interface Soap {

}

}}}

Using @Soap
{{{
package org.cdi.advocacy;

@Soap
public class SoapAtmTransport implements ATMTransport {

	@Override 
	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via Soap transport");
	}

}
}}}

Via constructor
{{{
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	private ATMTransport transport;

	@Inject 
	public AutomatedTellerMachineImpl(@Soap ATMTransport transport) {
		this.transport = transport;
	}

}}}

Via Property
{{{
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	private ATMTransport transport;

	@Inject 
	public void setTransport(@Soap ATMTransport transport) {
		this.transport = transport;
	}
}}}


Via Field
{{{
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject @Soap
	private ATMTransport transport;

}}}

==Using Instance to inject transports==

{{{
package org.cdi.advocacy;

import java.math.BigDecimal;

import javax.annotation.PostConstruct;
import javax.enterprise.inject.Default;
import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import javax.inject.Named;

@Named("atm")
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject @Soap 
	private Instance<ATMTransport> soapTransport;

	@Inject @Json 
	private Instance<ATMTransport> jsonTransport;

	@Inject @Default 
	private Instance<ATMTransport> defaultTransport;
	
	private ATMTransport transport;

	@PostConstruct
	protected void init() {
		if (!defaultTransport.isUnsatisfied()) {
			System.out.println("picked Default");
			transport = defaultTransport.iterator().next();
		} else if (!jsonTransport.isUnsatisfied()) {
			System.out.println("picked JSON");
			transport = jsonTransport.iterator().next();
		} else if (!soapTransport.isUnsatisfied()) {
			System.out.println("picked SOAP");
			transport = soapTransport.iterator().next();
		}
	}

}}}

Output
{{{
picked Default
deposit called
communicating with bank via Standard transport
}}}

Comment out implements ATMTransport in StandardAtmTransport
{{{
package org.cdi.advocacy;

import javax.enterprise.inject.Default;

@Default
public class StandardAtmTransport { //implements ATMTransport {

	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via Standard transport");
	}

}

}}}

Now the output is this:

{{{
picked JSON
deposit called
communicating with bank via JSON REST transport
}}}


Calling all installed transports.
Remove all of the annotations in the ATMTransport interfaces and make the beans.xml empty again.

{{{
package org.cdi.advocacy;

//import javax.enterprise.inject.Alternative;

//@Soap
public class SoapAtmTransport implements ATMTransport {

	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via Soap transport");
	}

}
}}}

{{{
package org.cdi.advocacy;

//import javax.enterprise.inject.Alternative;

//@Alternative @Json
public class JsonRestAtmTransport implements ATMTransport {

	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via JSON REST transport");
	}

}

}}}


{{{
package org.cdi.advocacy;

//import javax.enterprise.inject.Default;

//@Default
public class StandardAtmTransport implements ATMTransport {

	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via Standard transport");
	}

}

}}}

beans.xml
{{{
<beans xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
http://java.sun.com/xml/ns/javaee
http://java.sun.com/xml/ns/javaee/beans_1_0.xsd">
</beans>
}}}

Now use every transport that is installed using the @Any annotation.

{{{
package org.cdi.advocacy;

import java.math.BigDecimal;
import java.util.Iterator;

import javax.annotation.PostConstruct;
import javax.enterprise.inject.Any;
import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import javax.inject.Named;

@Named("atm")
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject @Any 
	private Instance<ATMTransport> allTransports;

	@PostConstruct
	protected void init() {
		System.out.println("Is this ambigous? " + allTransports.isAmbiguous() );
		System.out.println("Is this unsatisfied? " + allTransports.isUnsatisfied() );
	}
	
	public void deposit(BigDecimal bd) {
		System.out.println("deposit called");
		
		for (ATMTransport transport : this.allTransports) {
			transport.communicateWithBank(null);
		}
		
	}

	public void withdraw(BigDecimal bd) {
		System.out.println("withdraw called");

		for (ATMTransport transport : this.allTransports) {
			transport.communicateWithBank(null);
		}

	}

}
}}}


Output
{{{
Is this ambigous? true
Is this unsatisfied? false
deposit called
communicating with bank via JSON REST transport
communicating with bank via Soap transport
communicating with bank via Standard transport
}}}

Notice ...

Comment out the //implements ATMTransport { in the JSON and SOAP implementation.
You get this output
{{{
Output 
Is this ambigous? false
Is this unsatisfied? false
deposit called
communicating with bank via Standard transport
}}}

Notice ...

Now comment out all three //implements ATMTransport, and you get this:

{{{
Is this ambigous? false
Is this unsatisfied? true
deposit called
}}}

Notice ... 

Add the annotations we comment out, back to all of the transports. Take out the Alternative annotation for the JSON transport.



Change main ATM like so...

{{{
package org.cdi.advocacy;

import java.math.BigDecimal;

import javax.annotation.PostConstruct;
//import javax.enterprise.inject.Any;
import javax.enterprise.inject.Any;
import javax.enterprise.inject.Default;
import javax.enterprise.inject.Instance;
import javax.enterprise.util.AnnotationLiteral;
import javax.inject.Inject;
import javax.inject.Named;

@Named("atm")
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject @Any 
	private Instance<ATMTransport> allTransports;
	
	private ATMTransport transport;

	@PostConstruct
	protected void init() {
		transport = allTransports.select(new AnnotationLiteral<Default>(){}).get();
		
		if (transport!=null) {
			System.out.println("Found standard transport");
			return;
		}
		
		transport = allTransports.select(new AnnotationLiteral<Json>(){}).get();

		
		if (transport!=null) {
			System.out.println("Found JSON standard transport");
			return;
		}

		
		transport = allTransports.select(new AnnotationLiteral<Soap>(){}).get();
		
		
		if (transport!=null) {
			System.out.println("Found SOAP standard transport");
			return;
		}
		
	}
	

	public void deposit(BigDecimal bd) {
		System.out.println("deposit called");
		
		transport.communicateWithBank(null);
	}

       ...
}

}}}

Output
{{{
Found standard transport
deposit called
communicating with bank via Standard transport
}}}


Imagine there being setting that are configured in a db or something.

{{{
package org.cdi.advocacy;

import java.math.BigDecimal;

import javax.annotation.PostConstruct;
import javax.enterprise.inject.Any;
import javax.enterprise.inject.Default;
import javax.enterprise.inject.Instance;
import javax.enterprise.util.AnnotationLiteral;
import javax.inject.Inject;
import javax.inject.Named;

@Named("atm")
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject @Any 
	private Instance<ATMTransport> allTransports;
	
	private ATMTransport transport;
	
	//These could be looked up in a DB, JNDI or a properties file.
	private boolean useJSON = true;
	private boolean behindFireWall = true;

	@PostConstruct
	protected void init() {
		
		ATMTransport soapTransport, jsonTransport, standardTransport;
		
		standardTransport = allTransports.select(new AnnotationLiteral<Default>(){}).get();
		jsonTransport = allTransports.select(new AnnotationLiteral<Json>(){}).get();
		soapTransport = allTransports.select(new AnnotationLiteral<Soap>(){}).get();

		if (!behindFireWall) {
			transport = standardTransport;
		} else {
			if (useJSON) {
				transport = jsonTransport;
			} else {
				transport = soapTransport;
			}
		}		
		
	}
	

	public void deposit(BigDecimal bd) {
		System.out.println("deposit called");
		
		transport.communicateWithBank(null);
	}

	public void withdraw(BigDecimal bd) {
		System.out.println("withdraw called");

		transport.communicateWithBank(null);

	}

}

}}}

==Using @Produces==
TBD

==Configuring transports via annotations and @Produces==
TBD

==Scopes and lifecycle==
TBD

==The dirty truth about CDI and Java SE==
TBD

== Conclusion ==