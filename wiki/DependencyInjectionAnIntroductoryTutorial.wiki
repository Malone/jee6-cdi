#summary Dependency Injection - An Introductory Tutorial
#sidebar TOCArticlesDependencyInjectionAnIntroductoryTutorial

<h1> Dependency Injection - An Introductory Tutorial -- Under Construction </h1>


<wiki:toc max_depth="5" />


= Introduction =

This article discusses dependency injection in a tutorial format. It covers some of the features of CDI such as type safe annotations configuration, alternatives and more. 

[http://jcp.org/aboutJava/communityprocess/final/jsr299/index.html CDI] is the Java standard for dependency injection and interception (AOP). It is evident from the popularity of DI and AOP that Java needs to address DI and AOP so that it can build other standards on top of it. DI and AOP are the foundation of many Java frameworks.

CDI is a foundational aspect of Java EE 6. It is or will be shortly supported by Caucho's Resin, IBM's !WebSphere, Oracle's Glassfish, Red Hat's JBoss and many more application servers. CDI is similar to core Spring and Guice frameworks. Like JPA did for ORM, CDI simplifies and sanitizes the API for DI and AOP. If you have worked with Spring or Guice, you find CDI easy to use and easy to learn.

It is no accident that this tutorial follows this tutorial [http://java.dzone.com/articles/dependency-injection-an-introd (using Spring "new" DI annotations)] written three years ago. It will be interesting to compare and contrast the examples in this tutorial with the one written three years ago for Spring DI annotations.


= Dependency Injection =

Dependency Injection (DI) refers to the process of supplying an external dependency to a software component. DI can help make your code architecturally pure. It aids in design by interface as well as test-driven development by providing a consistent way to inject dependencies. For example, a data access object (DAO) may depend on a database connection. Instead of looking up the database connection with JNDI, you could inject it. 

One way to think about a DI framework like CDI is to think of JNDI turned inside out. Instead of an object looking up other objects that it needs to get its job done (dependencies), a DI container injects those dependent objects. This is the so-called Hollywood Principle, “Don't call us” (lookup objects), “we’ll call you” (inject objects). 

If you have worked with CRC cards you can think of a dependency as a collaborator, i.e., an object that another object needs to perform its role.
 
==Dependency Injection-`AutomatedTellerMachine` without CDI or Spring or Guice==

Let's say that you have an automated teller machine (ATM, also known as an automated banking machine in other countries) and it needs the ability to talk to a bank. It uses what it calls a transport object to do this. In this example, a transport object handles the low-level communication to the bank. 

This example could be represented by these two interfaces as follows: 

====Code Listing: `AutomatedTellerMachine` interface====

{{{
package org.cdi.advocacy;

import java.math.BigDecimal;

public interface AutomatedTellerMachine {

	public abstract void deposit(BigDecimal bd);

	public abstract void withdraw(BigDecimal bd);

}
}}}

====Code Listing: ATMTransport interface====
{{{
package org.cdi.advocacy;

public interface ATMTransport {
	public void communicateWithBank(byte[] datapacket);
}
}}}

Now the *`AutomatedTellerMachine`* needs a transport to perform its intent, namely withdraw money and deposit money. To carry out these tasks, the *`AutomatedTellerMachine`* may depend on many objects and collaborates with its dependencies to complete the work. 

An implementation of the *`AutomatedTellerMachine`* may look like this:

====Code Listing: AutomatedTellerMachineImpl class====
{{{
package org.cdi.advocacy;
...
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	private ATMTransport transport;
	
        ...
	public void deposit(BigDecimal bd) {
		System.out.println("deposit called");
		transport.communicateWithBank(...);
	}

	public void withdraw(BigDecimal bd) {
		System.out.println("withdraw called");
		transport.communicateWithBank(...);
	}

}

}}}

The *`AutomatedTellerMachineImpl`* does not know or care how the transport withdraws and deposits money from the bank. This level of indirection allows us to replace the transport with different implementations such as in the following example:

===Three example transports: `SoapAtmTransport`, `StandardAtmTransport` and `JsonAtmTransport`===

====Code Listing: `StandardAtmTransport`====
{{{
package org.cdi.advocacy;


public class StandardAtmTransport implements ATMTransport {

	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via Standard transport");
                ...
	}

}
}}}

====Code Listing: `SoapAtmTransport`====
{{{
package org.cdi.advocacy;

public class SoapAtmTransport implements ATMTransport {

	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via Soap transport");
                ...
	}

}

}}}


====Code Listing: `JsonRestAtmTransport`====
{{{
package org.cdi.advocacy;

public class JsonRestAtmTransport implements ATMTransport {

	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via JSON REST transport");
	}

}
}}}

Notice the possible implementations of the *`ATMTransport interface`*. The `*AutomatedTellerMachineImpl*` does not know or care which transport it uses. Also, for testing and developing, instead of talking to a real bank, you could easily use Mockito or EasyMock or you could even write a *`SimulationAtmTransport`*.


The concept of DI transcends CDI, Guice and Spring. Thus, you can accomplish DI without CDI or Spring as follows: 

====Code Listing: `AtmMain`: DI without CDI, Spring or Guice====

{{{
package org.cdi.advocacy;

public class AtmMain {
        
        public void main (String[] args) {
                AutomatedTellerMachine atm = new AutomatedTellerMachineImpl();
                ATMTransport transport = new SoapAtmTransport();
                /* Inject the transport. */           
                ((AutomatedTellerMachineImpl)atm).setTransport(transport);
                
                atm.withdraw(new BigDecimal("10.00"));
                
                atm.deposit(new BigDecimal("100.00"));
        }

}
}}}

Then injecting a different *transport* is a mere matter of calling a different setter method as follows:

====Code Listing: `AtmMain`: DI without CDI, Spring or Guice: `setTransport`====
{{{
ATMTransport transport = new SimulationAtmTransport();
((AutomatedTellerMachineImpl)atm).setTransport(transport);
}}}


The above assumes we added a *`setTransport`* method to the *`AutomateTellerMachineImpl`*. Note you could just as easily use constructor arguments instead of a setter method. Thus keeping the interface of your *`AutomateTellerMachineImpl`* clean.

==Dependency Injection-`AutomatedTellerMachine` using CDI==


To use CDI to manage the dependencies you could do the following:
 # Create an empty *bean.xml* file under *META-INF* resource folder
 # Use the *@Inject* annotation to annotate a *`setTransport`* setter method in *`AutomatedTellerMachineImpl`*
 # Use the *@Default* annotation to annotate the *`StandardAtmTransport`*
 # Use the *@Alternative* to annotate the *`SoapAtmTransport`*, and *`JsonRestAtmTransport`*.
 # Use the *@Named* annotation to make the *`AutomatedTellerMachineImpl`* easy to look up; give it the name "atm"
 # Use the CDI *`beanContainer`* to look the *atm*, makes some deposits and withdraws.


===Step 1: Create an empty *bean.xml* file under *META-INF* resource folder ===
===META-INF/beans.xml===

CDI needs an bean.xml file to be in META-INF of your jar file or classpath or WEB-INF of your web application. This file can be completely empty (as in 0 bytes). If there is no beans.xml file in your META-INF or WEB-INF then that war file or jar file will not be processed by CDI. Otherwise, CDI will scan the jar and war file if the beans.xml file exists even if it is 0 bytes.

==== Code Listing: `META-INF/beans.xml` just as empty as can be====

{{{
<beans xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
http://java.sun.com/xml/ns/javaee
http://java.sun.com/xml/ns/javaee/beans_1_0.xsd">

</beans>
}}}

Notice that we included a starter beans.xml file with a namespace and a `<beans>` element. Although *beans.xml* could be completely empty, it is nice to have a starter file so when you need to add things (like later on in this tutorial) you can readily. Also it keeps the IDE from complaining about ill formed xml when you actually do have a 0 byte beans.xml. (I hate when the IDE complains. It is very distracting.)


===Step 2: Use the *@Inject* annotation to annotate a *`setTransport`* setter method in *`AutomatedTellerMachineImpl`*===

The *@Inject* annotation is used to mark where an injection goes. You can annotate constructor arguments, instance fields and setter methods of properties. In this example, we will annotate the *setTransport* method (which would be the setter method of the transport property).

====Code Listing: `AutomatedTellerMachineImpl` using *@Inject* to inject a transport====

{{{
package org.cdi.advocacy;

...

import javax.inject.Inject;

public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	private ATMTransport transport;

	@Inject
	public void setTransport(ATMTransport transport) {
		this.transport = transport;
	}

       ...

}

}}}

By default, CDI would look for a class that implements the *`ATMTransport`* interface, once it finds this it creates an instance and injects this instance of *`ATMTransport`* using the setter method *`setTransport`*. If we only had one possible instance of *`ATMTransport`* in our classpath, we would not need to annotate any of the *`ATMTransport`* implementations. Since we have three, namely, *`StandardAtmTransport`*, *`SoapAtmTransport`*,  and *`JsonAtmTransport`*, we need to mark two of them as *`@Alternative`*s and one as *`@Default`*.

===Step 3: Use the *@Default* annotation to annotate the *`StandardAtmTransport`*===

At this stage of the example, we would like our default transport to be *`StandardAtmTransport`*; thus, we mark it as *`@Default`* as follows:.

==== Code Listing: `StandardAtmTransport` using *@Default*====
{{{
package org.cdi.advocacy;

import javax.enterprise.inject.Default;

@Default
public class StandardAtmTransport implements ATMTransport {
    ...

}}}

It should be noted that a class is @Default by default. Thus marking it so is redundant; and not only that its redundant. 

=== Step 4: Use the *@Alternative* to annotate the *`SoapAtmTransport`*, and *`JsonRestAtmTransport`*. ===

If we don't mark the others as @Alternative, they are by default as far as CDI is concerned, marked as @Default.  Let's mark *`JsonRestAtmTransport`* and *`SoapRestAtmTransport`* *@Alternative* so CDI does not get confused.

==== Code Listing: `JsonRestAtmTransport` using *@Alternative*====
{{{
package org.cdi.advocacy;

import javax.enterprise.inject.Alternative;

@Alternative
public class JsonRestAtmTransport implements ATMTransport {

...
}

}}}

==== Code Listing: `SoapAtmTransport` using *@Alternative*====
{{{
package org.cdi.advocacy;

import javax.enterprise.inject.Alternative;

@Alternative
public class SoapAtmTransport implements ATMTransport {
   ...
}

}}}


 === Step 5: Use the *@Named* annotation to make the *`AutomatedTellerMachineImpl`* easy to look up; give it the name "atm"===

Since we are not using `AutomatedTellerMachineImpl` from a Java EE 6 application, let's just use the *`beanContainer`* to look it up. Let's give it an easy logical name like "atm". To give it a name, use the @Named annotation. The @Named annotation is also used by JEE 6 application to make the bean accessible via the Universal EL (EL stands for Expression language and it gets used by JSPs and JSF components).

Here is an example of using @Named to give the *`AutomatedTellerMachineImpl`* the name "atm"as follows:

==== Code Listing: `AutomatedTellerMachineImpl` using *@Named*====
{{{
package org.cdi.advocacy;

import java.math.BigDecimal;

import javax.inject.Inject;
import javax.inject.Named;

@Named("atm")
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
       ...

}
}}}



=== Step 6: Use the CDI *`beanContainer`* to look up the *atm*, makes some deposits and withdraws. ===

Lastly we want to look up the *atm* using the *`beanContainer`* and make some deposits.
 
==== Code Listing: `AtmMain` looking up the atm ====
{{{
package org.cdi.advocacy;

...

public class AtmMain {

        ...
        ...

	public static void main(String[] args) throws Exception {
		AutomatedTellerMachine atm = (AutomatedTellerMachine) beanContainer
				.getBeanByName("atm");

		atm.deposit(new BigDecimal("1.00"));

	}

}
}}}

When you run it from the command line, you should get the following:

{{{
deposit called
communicating with bank via Standard transport
}}}

If you remove the *@Default* from the *`StandardATMTransport`*, you will get the same output.
If you remove the *@Alternative* from both of the other transports, namely,  *`JsonATMTransport`*, and  *`SoapATMTransport`*, CDI will croak as follows:

{{{
Exception in thread "main" java.lang.ExceptionInInitializerError
Caused by: javax.enterprise.inject.AmbiguousResolutionException: org.cdi.advocacy.AutomatedTellerMachineImpl.setTransport: 
Too many beans match, because they all have equal precedence.  
See the @Stereotype and <enable> tags to choose a precedence.  Beans:
    ManagedBeanImpl[JsonRestAtmTransport, {@Default(), @Any()}]
    ManagedBeanImpl[SoapAtmTransport, {@Default(), @Any()}]
    ManagedBeanImpl[StandardAtmTransport, {@javax.enterprise.inject.Default(), @Any()}]
   ...
}}} 

==Using @Inject to inject via constructor args and fields==
TBD Under construction

Field injection.
{{{
...
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject
	private ATMTransport transport;

}}}

Constructor injection.
{{{
...
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject 
	public AutomatedTellerMachineImpl(ATMTransport transport) {
		this.transport = transport;
	}

}}}

==Using simple @Produces==
Under Construction....

Simple producer

{{{
package org.cdi.advocacy;

import javax.enterprise.inject.Produces;

public class TransportFactory {
		
	@Produces ATMTransport createTransport() {
		System.out.println("ATMTransport created with producer");
		return new StandardAtmTransport();
	}

}
}}}

ATM machine code to receive simplr producer

{{{
import javax.inject.Inject;
import javax.inject.Named;

@Named("atm")
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject
	private ATMTransport transport;
        ...
}}}

Output
{{{
ATMTransport created with producer
deposit called
communicating with bank via Standard transport
}}}



==Using @Alternative to select an Alternative==
TBD under construction

/META-INF/beans.xml
{{{
<beans xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
http://java.sun.com/xml/ns/javaee
http://java.sun.com/xml/ns/javaee/beans_1_0.xsd">
	<alternatives>
		<class>org.cdi.advocacy.JsonRestAtmTransport</class>
	</alternatives>
</beans>
}}}

Output
{{{
deposit called
communicating with bank via JSON REST transport
}}}



==Using @Qualifier to inject different types==
TBD

Soap Qualifier
{{{
package org.cdi.advocacy;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.*;

import javax.inject.Qualifier;


@Qualifier @Retention(RUNTIME) @Target({TYPE, METHOD, FIELD, PARAMETER})
public @interface Soap {

}

}}}

Using @Soap
{{{
package org.cdi.advocacy;

@Soap
public class SoapAtmTransport implements ATMTransport {

	@Override 
	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via Soap transport");
	}

}
}}}

Via constructor
{{{
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	private ATMTransport transport;

	@Inject 
	public AutomatedTellerMachineImpl(@Soap ATMTransport transport) {
		this.transport = transport;
	}

}}}

Via Property
{{{
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	private ATMTransport transport;

	@Inject 
	public void setTransport(@Soap ATMTransport transport) {
		this.transport = transport;
	}
}}}


Via Field
{{{
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject @Soap
	private ATMTransport transport;

}}}

==Using @Qualfiers to inject multiple types into the same bean using ==
Under construction....


{{{
package org.cdi.advocacy;

import java.math.BigDecimal;

import javax.annotation.PostConstruct;
import javax.inject.Inject;
import javax.inject.Named;

@Named("atm")
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	private ATMTransport transport;
	
	@Inject @Soap
	private ATMTransport soapTransport;
	
	@Inject @Json
	private ATMTransport jsonTransport;
	
	@Inject @Json
	private ATMTransport standardTransport;

	
	//These could be looked up in a DB, JNDI or a properties file.
	private boolean useJSON = true;
	private boolean behindFireWall = true;

	@PostConstruct
	protected void init() {
                //Look up values for useJSON and behindFireWall		

		if (!behindFireWall) {
			transport = standardTransport;
		} else {
			if (useJSON) {
				transport = jsonTransport;
			} else {
				transport = soapTransport;
			}
		}
				
	}
	

	public void deposit(BigDecimal bd) {
		System.out.println("deposit called");
		
		
		transport.communicateWithBank(null);
	}

       ...
}

}}}

{{{
deposit called
communicating with bank via JSON REST transport
}}}


==Using @Producer to make a decision about creation==

Under construction...

Producer that makes a decision about creation


{{{
package org.cdi.advocacy;

import javax.enterprise.inject.Produces;

public class TransportFactory {
	
	private boolean useJSON = true;
	private boolean behindFireWall = true;

	
	@Produces ATMTransport createTransport() {
		//Look up config parameters in some config file
		System.out.println("ATMTransport created with producer makes decisions");
		
		if (behindFireWall) {
			if (useJSON) {
				System.out.println("Created JSON transport");
				return new JsonRestAtmTransport();
			} else {
				System.out.println("Created SOAP transport");
				return new SoapAtmTransport();
			}
		} else {
			System.out.println("Created Standard transport");
			return new StandardAtmTransport();
		}
	}

}

}}}

Output
{{{
ATMTransport created with producer makes decisions
Created JSON transport
deposit called
communicating with bank via JSON REST transport
}}}



==Using @Producer that uses Qualifiers to make a decision about creation==

You can also inject items as arguments into the producer as follows:

{{{
package org.cdi.advocacy;

import javax.enterprise.inject.Produces;

public class TransportFactory {
	
	private boolean useJSON = true;
	private boolean behindFireWall = true;

	
	@Produces ATMTransport createTransport(	@Soap ATMTransport soapTransport, 
											@Json ATMTransport jsonTransport) {
		//Look up config parameters in some config file
		System.out.println("ATMTransport created with producer makes decisions");
		
		if (behindFireWall) {
			if (useJSON) {
				System.out.println("return passed JSON transport");
				return jsonTransport;
			} else {
				System.out.println("return passed SOAP transport");
				return soapTransport;
			}
		} else {
			System.out.println("Create Standard transport");
			return new StandardAtmTransport();
		}
	}

}

}}}

{{{
ATMTransport created with producer makes decisions
return passed JSON transport
deposit called
communicating with bank via JSON REST transport
}}}



== Using @Qualfiers with members to discriminate injection and stop the explosion of annotation creation==

There could be an explosion of qualifers annotations in your project. 
This is probably not want you want.
It is okay if you have a few, but it could quickly become unmaneagle.

Instead of having three qualifier you could have one qualifier and an enum.
Then if you need more types of transports, you only have to add an enum value instead of another class.

{{{
package org.cdi.advocacy;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.*;

import javax.inject.Qualifier;


@Qualifier @Retention(RUNTIME) @Target({TYPE, METHOD, FIELD, PARAMETER})
public @interface Transport {
	TransportType type() default TransportType.STANDARD;
}

}}}

{{{
package org.cdi.advocacy;

public enum TransportType {
	JSON, SOAP, STANDARD;
}
}}}

Imagine in our example if there were 20 types of transports. We would have 20 annotations defined.

You would need to annotated the implementations like so:

{{{
package org.cdi.advocacy;


@Transport(type=TransportType.SOAP)
public class SoapAtmTransport implements ATMTransport {
    ...
}}}

{{{
package org.cdi.advocacy;

@Transport(type=TransportType.STANDARD)
public class StandardAtmTransport implements ATMTransport {
    ...

}}}

{{{
package org.cdi.advocacy;

@Transport(type=TransportType.JSON)
public class JsonRestAtmTransport implements ATMTransport {
     ...
}}}

{{{
@Named("atm")
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {

	@Inject @Transport(type=TransportType.STANDARD)
	private ATMTransport transport;

}}}

Output
{{{
deposit called
communicating with bank via Standard transport
}}}

You can have more than one member of the qualifier annotation as follows:

{{{
package org.cdi.advocacy;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.*;

import javax.inject.Qualifier;


@Qualifier @Retention(RUNTIME) @Target({TYPE, METHOD, FIELD, PARAMETER})
public @interface Transport {
	TransportType type() default TransportType.STANDARD;
	int priorityLevel() default -1;
}

}}}

Now CDI is going to use both of the members to discriminate for injection.

If we had a transport like so:

{{{
package org.cdi.advocacy;

@Transport(type=TransportType.STANDARD, priorityLevel=1)
public class SuperFastAtmTransport implements ATMTransport {
	

	public void setRetries(int retries) {
	}


	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via the Super Fast transport ");
	}

}

}}}

No changes to the StandardAtmTransport.

If we run without changing the AutomatedTellerMachineImpl, we will get:

Output
{{{
deposit called
communicating with bank via the Standard transport 
}}}

If we change the injection and set the priority level to 1 like so:

{{{
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject @Transport(type=TransportType.STANDARD, priorityLevel=1)
	private ATMTransport transport;


}}}

Then we get this:

Output 

{{{
deposit called
communicating with bank via the Super Fast transport 
}}}

You can match using any type supported by annotations, e.g., Strings, classes, enums, ints, etc.



= Advanced CDI tutorial =
The faint of heart stop hear. All of the folks who want to understand the inner workings of CDI continue.

==Advanced: Using @Produces and InjectionPoint to create configuration annotations==
Our ultimate goal is to define an annotation that we can use to configure the retry count on a transport.

We want something that looks like this:

{{{
	@Inject @TransportConfig(retries=2)
	private ATMTransport transport;

}}}

Before we do that we need to learn more about Produces and InjectionPoints.

Let's learn about passing an injection point to @Produces

{{{
package org.cdi.advocacy;

//import javax.enterprise.inject.Default;
import javax.enterprise.inject.Produces;
import javax.enterprise.inject.spi.InjectionPoint;

public class TransportFactory {
	
	
	@Produces ATMTransport createTransport(InjectionPoint injectionPoint) {
		
		System.out.println("annotated " + injectionPoint.getAnnotated());
		System.out.println("bean " + injectionPoint.getBean());
		System.out.println("member " + injectionPoint.getMember());
		System.out.println("qualifiers " + injectionPoint.getQualifiers());
		System.out.println("type " + injectionPoint.getType());
		System.out.println("isDelegate " + injectionPoint.isDelegate());
		System.out.println("isTransient " + injectionPoint.isTransient());
	
		return new StandardAtmTransport();
				
	}

}

}}}

Output
{{{
annotated AnnotatedFieldImpl[private org.cdi.advocacy.ATMTransport org.cdi.advocacy.AutomatedTellerMachineImpl.transport]
bean ManagedBeanImpl[AutomatedTellerMachineImpl, {@javax.inject.Named(value=atm), @Default(), @Any()}, name=atm]
member private org.cdi.advocacy.ATMTransport org.cdi.advocacy.AutomatedTellerMachineImpl.transport
qualifiers [@Default()]
type interface org.cdi.advocacy.ATMTransport
isDelegate false
isTransient false
deposit called
communicating with bank via Standard transport
}}}

//Post a link to the API documents

It appears from the output that annotated tells us which area of the program was annotated.
It also appears that bean tells us which bean the injection is happending in.

Drilling further you can see what is in the beans and annotated properties.

{{{
	@Produces ATMTransport createTransport(InjectionPoint injectionPoint) {
		
		System.out.println("annotated " + injectionPoint.getAnnotated());
		System.out.println("bean " + injectionPoint.getBean());
		System.out.println("member " + injectionPoint.getMember());
		System.out.println("qualifiers " + injectionPoint.getQualifiers());
		System.out.println("type " + injectionPoint.getType());
		System.out.println("isDelegate " + injectionPoint.isDelegate());
		System.out.println("isTransient " + injectionPoint.isTransient());

		Bean<?> bean = injectionPoint.getBean();
		
		System.out.println("bean.beanClass " + bean.getBeanClass());
		System.out.println("bean.injectionPoints " + bean.getInjectionPoints());
		System.out.println("bean.name " + bean.getName());
		System.out.println("bean.qualifiers " + bean.getQualifiers());
		System.out.println("bean.scope " + bean.getScope());
		System.out.println("bean.stereotypes " + bean.getStereotypes());
		System.out.println("bean.types " + bean.getTypes());
		
		Annotated annotated = injectionPoint.getAnnotated();
		System.out.println("annotated.annotations " + annotated.getAnnotations());
		System.out.println("annotated.annotations " + annotated.getBaseType());
		System.out.println("annotated.typeClosure " + annotated.getTypeClosure());
		
		return new StandardAtmTransport();
}
}}}


Output
{{{
...
bean.beanClass class org.cdi.advocacy.AutomatedTellerMachineImpl
bean.injectionPoints [InjectionPointImpl[private org.cdi.advocacy.ATMTransport org.cdi.advocacy.AutomatedTellerMachineImpl.transport]]
bean.name atm
bean.qualifiers [@javax.inject.Named(value=atm), @Default(), @Any()]
bean.scope interface javax.enterprise.context.Dependent
bean.stereotypes []
bean.types [class org.cdi.advocacy.AutomatedTellerMachineImpl, interface org.cdi.advocacy.AutomatedTellerMachine, class java.lang.Object]
annotated.annotations AnnotationSet[@javax.inject.Inject()]
annotated.annotations interface org.cdi.advocacy.ATMTransport
annotated.typeClosure [interface org.cdi.advocacy.ATMTransport, class java.lang.Object]
...
}}}

Ok now that we armed with an idea of what an Injection piont is. Let's get configuring our transport.

First let's define an TransportConfig annotation.

{{{
package org.cdi.advocacy;


import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.*;



@Retention(RUNTIME) @Target({TYPE, METHOD, FIELD, PARAMETER})
public @interface TransportConfig {
	int retries() default 5;
}

}}}

Now go ahead and use this to decorate the injection point as follows:

{{{
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject @TransportConfig(retries=2)
	private ATMTransport transport;

}}}

Once it is configured when you run it, you will see the following output from our producer:

{{{
annotated.annotations AnnotationSet[@javax.inject.Inject(), @org.cdi.advocacy.TransportConfig(retries=2)]
}}}

This means the annotation data is there. We just need to grab it and use it.

Now we need to change the transport implementations to handle setting retires. Since this is an example, I will do this simply by adding a new setter method for retires (setRetries) to the ATMTranport interface like so:

{{{
package org.cdi.advocacy;

public interface ATMTransport {
	public void communicateWithBank(byte[] datapacket);
	public void setRetries(int retries);
}

}}}

Then we need to change each of the transport to handle this new property as follows:

{{{
package org.cdi.advocacy;

public class StandardAtmTransport implements ATMTransport {
	
	private int retries;

	public void setRetries(int retries) {
		this.retries = retries;
	}


	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via Standard transport retries=" + retries);
	}

}
}}}

Now we just change the producer to grab the new annotation and configure the transport as follows:

(For clarity I took out all of the Sysout.prinltns)
{{{
package org.cdi.advocacy;

...
import javax.enterprise.inject.spi.Annotated;
import javax.enterprise.inject.spi.Bean;
import javax.enterprise.inject.spi.InjectionPoint;

public class TransportFactory {
	@Produces ATMTransport createTransport(InjectionPoint injectionPoint) {
		
		Annotated annotated = injectionPoint.getAnnotated();
		
		TransportConfig transportConfig = annotated.getAnnotation(TransportConfig.class);
		
		
		
		StandardAtmTransport transport = new StandardAtmTransport();
		
		transport.setRetries(transportConfig.retries());
		return transport;
	}

}

}}}

(Side Note we are missing a null pointer check. The annotation configuration could be null if the user did not set it, you may want to handle this. The example is kept deliberately short.)

The code just gets the annotation and shoves in the retires into the transport, and then just returns the transport.
We now have a producers that can use an annotation to configure an injection. 

Here is our new output:

{{{
...
deposit called
communicating with bank via Standard transport retries=2
}}}

You can see our retries are there as we configured them in the output.

Let's say we had multiple transports in a single ATM and you wanted to configure all of the outputs at once. Oh my! Easy enough.

{{{
public class TransportFactory {
	@Produces ATMTransport createTransport(InjectionPoint injectionPoint) {
		
		Bean<?> bean = injectionPoint.getBean();
		TransportConfig transportConfig = bean.getBeanClass().getAnnotation(TransportConfig.class);

		StandardAtmTransport transport = new StandardAtmTransport();
		
		transport.setRetries(transportConfig.retries());
		return transport;

}}}

It is an exercise for the reader to make the injection level annotation (from the last example) override the class level annotations.

Output
{{{
deposit called
communicating with bank via Standard transport retries=7
}}}


==Advanced: Using Instance to inject transports==

{{{
package org.cdi.advocacy;

import java.math.BigDecimal;

import javax.annotation.PostConstruct;
import javax.enterprise.inject.Default;
import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import javax.inject.Named;

@Named("atm")
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject @Soap 
	private Instance<ATMTransport> soapTransport;

	@Inject @Json 
	private Instance<ATMTransport> jsonTransport;

	@Inject @Default 
	private Instance<ATMTransport> defaultTransport;
	
	private ATMTransport transport;

	@PostConstruct
	protected void init() {
		if (!defaultTransport.isUnsatisfied()) {
			System.out.println("picked Default");
			transport = defaultTransport.iterator().next();
		} else if (!jsonTransport.isUnsatisfied()) {
			System.out.println("picked JSON");
			transport = jsonTransport.iterator().next();
		} else if (!soapTransport.isUnsatisfied()) {
			System.out.println("picked SOAP");
			transport = soapTransport.iterator().next();
		}
	}

}}}

Output
{{{
picked Default
deposit called
communicating with bank via Standard transport
}}}

Comment out implements ATMTransport in StandardAtmTransport
{{{
package org.cdi.advocacy;

import javax.enterprise.inject.Default;

@Default
public class StandardAtmTransport { //implements ATMTransport {

	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via Standard transport");
	}

}

}}}

Now the output is this:

{{{
picked JSON
deposit called
communicating with bank via JSON REST transport
}}}


Calling all installed transports.
Remove all of the annotations in the ATMTransport interfaces and make the beans.xml empty again.

{{{
package org.cdi.advocacy;

//import javax.enterprise.inject.Alternative;

//@Soap
public class SoapAtmTransport implements ATMTransport {

	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via Soap transport");
	}

}
}}}

{{{
package org.cdi.advocacy;

//import javax.enterprise.inject.Alternative;

//@Alternative @Json
public class JsonRestAtmTransport implements ATMTransport {

	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via JSON REST transport");
	}

}

}}}


{{{
package org.cdi.advocacy;

//import javax.enterprise.inject.Default;

//@Default
public class StandardAtmTransport implements ATMTransport {

	public void communicateWithBank(byte[] datapacket) {
		System.out.println("communicating with bank via Standard transport");
	}

}

}}}

beans.xml
{{{
<beans xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="
http://java.sun.com/xml/ns/javaee
http://java.sun.com/xml/ns/javaee/beans_1_0.xsd">
</beans>
}}}

Now use every transport that is installed using the @Any annotation.

{{{
package org.cdi.advocacy;

import java.math.BigDecimal;
import java.util.Iterator;

import javax.annotation.PostConstruct;
import javax.enterprise.inject.Any;
import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import javax.inject.Named;

@Named("atm")
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject @Any 
	private Instance<ATMTransport> allTransports;

	@PostConstruct
	protected void init() {
		System.out.println("Is this ambigous? " + allTransports.isAmbiguous() );
		System.out.println("Is this unsatisfied? " + allTransports.isUnsatisfied() );
	}
	
	public void deposit(BigDecimal bd) {
		System.out.println("deposit called");
		
		for (ATMTransport transport : this.allTransports) {
			transport.communicateWithBank(null);
		}
		
	}

	public void withdraw(BigDecimal bd) {
		System.out.println("withdraw called");

		for (ATMTransport transport : this.allTransports) {
			transport.communicateWithBank(null);
		}

	}

}
}}}


Output
{{{
Is this ambigous? true
Is this unsatisfied? false
deposit called
communicating with bank via JSON REST transport
communicating with bank via Soap transport
communicating with bank via Standard transport
}}}

Notice ...

Comment out the //implements ATMTransport { in the JSON and SOAP implementation.
You get this output
{{{
Output 
Is this ambigous? false
Is this unsatisfied? false
deposit called
communicating with bank via Standard transport
}}}

Notice ...

Now comment out all three //implements ATMTransport, and you get this:

{{{
Is this ambigous? false
Is this unsatisfied? true
deposit called
}}}

Notice ... 

Add the annotations we comment out, back to all of the transports. Take out the Alternative annotation for the JSON transport.



Change main ATM like so...

{{{
package org.cdi.advocacy;

import java.math.BigDecimal;

import javax.annotation.PostConstruct;
//import javax.enterprise.inject.Any;
import javax.enterprise.inject.Any;
import javax.enterprise.inject.Default;
import javax.enterprise.inject.Instance;
import javax.enterprise.util.AnnotationLiteral;
import javax.inject.Inject;
import javax.inject.Named;

@Named("atm")
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject @Any 
	private Instance<ATMTransport> allTransports;
	
	private ATMTransport transport;

	@PostConstruct
	protected void init() {
		transport = allTransports.select(new AnnotationLiteral<Default>(){}).get();
		
		if (transport!=null) {
			System.out.println("Found standard transport");
			return;
		}
		
		transport = allTransports.select(new AnnotationLiteral<Json>(){}).get();

		
		if (transport!=null) {
			System.out.println("Found JSON standard transport");
			return;
		}

		
		transport = allTransports.select(new AnnotationLiteral<Soap>(){}).get();
		
		
		if (transport!=null) {
			System.out.println("Found SOAP standard transport");
			return;
		}
		
	}
	

	public void deposit(BigDecimal bd) {
		System.out.println("deposit called");
		
		transport.communicateWithBank(null);
	}

       ...
}

}}}

Output
{{{
Found standard transport
deposit called
communicating with bank via Standard transport
}}}


Imagine there being setting that are configured in a db or something.

{{{
package org.cdi.advocacy;

import java.math.BigDecimal;

import javax.annotation.PostConstruct;
import javax.enterprise.inject.Any;
import javax.enterprise.inject.Default;
import javax.enterprise.inject.Instance;
import javax.enterprise.util.AnnotationLiteral;
import javax.inject.Inject;
import javax.inject.Named;

@Named("atm")
public class AutomatedTellerMachineImpl implements AutomatedTellerMachine {
	
	@Inject @Any 
	private Instance<ATMTransport> allTransports;
	
	private ATMTransport transport;
	
	//These could be looked up in a DB, JNDI or a properties file.
	private boolean useJSON = true;
	private boolean behindFireWall = true;

	@PostConstruct
	protected void init() {
		
		ATMTransport soapTransport, jsonTransport, standardTransport;
		
		standardTransport = allTransports.select(new AnnotationLiteral<Default>(){}).get();
		jsonTransport = allTransports.select(new AnnotationLiteral<Json>(){}).get();
		soapTransport = allTransports.select(new AnnotationLiteral<Soap>(){}).get();

		if (!behindFireWall) {
			transport = standardTransport;
		} else {
			if (useJSON) {
				transport = jsonTransport;
			} else {
				transport = soapTransport;
			}
		}		
		
	}
	

	public void deposit(BigDecimal bd) {
		System.out.println("deposit called");
		
		transport.communicateWithBank(null);
	}

	public void withdraw(BigDecimal bd) {
		System.out.println("withdraw called");

		transport.communicateWithBank(null);

	}

}

}}}


==The dirty truth about CDI and Java SE==
TBD

= Conclusion =
= Resources =