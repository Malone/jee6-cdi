#summary CDI and Spring living in harmony

= Introduction =

<p>
Spring is very popular. CDI is very new. Although CDI is the standard for DI and Interception (light weight AOP), it is not a ubiquitous and Spring. 
</p>

<p>
Part of CDI success will be probably be indicative on how well it can play and integrate with Spring.
</p>

<p>
Realizing this, we took a Roo generated application, and fooled around with it until we were able to inject CDI beans into Spring objects. This effort is called the Spring CDI Bridge.
</p>

<p>
This basically allows you to inject CDI managed beans into Spring. We also had to go the other direction. We need the ability to inject Spring beans into CDI. This effort is called the CDI Spring Extension.
</p>

<p>
The golden ticket, is to be able to inject Spring beans into CDI beans that are then injected into Spring beans ad infinitum. This is tricky due to the different lifecycles and typing systems involved in Spring and CDI. We have achieved this as well.
</p>


== Bridging from the CDI World into Spring ==

In order to bridge from the CDI world into the Spring world, we created a [http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html BeanFactoryPostProcessor].
This CdiBeanFactoryPostProcessor looks the CDI [http://docs.jboss.org/cdi/api/latest/javax/enterprise/inject/spi/BeanManager.html BeanManager] in JNDI and uses it to find beans in CDI and map them as Spring bean definitions as follows:

*applicationContext.xml example configuring a CdiBeanFactoryPostProcessor*
{{{
	<bean class="org.cdisource.springintegration.CdiBeanFactoryPostProcessor" />
}}}

<p>
If you do not want to configure a BeanFactoryPostProcessor, you can also use CdiFactoryBean's to individually create bridges to CDI. CdiFactoryBean is similar to [http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/jndi/JndiObjectFactoryBean.html JndiObjectFactoryBean]. In fact the CdiBeanFactoryPostProcessor configures bean definitions that are really CdiFactoryBean configured to look up a class in CDI.
</p>.

*applicationContext.xml example configuring a CdiFactoryBean to lookup a TaskRepository*
{{{
 <bean class="org.cdisource.springintegration.CdiFactoryBean" name="taskRespository" >
        <property name="beanClass" value="org.cdisource.springapp.TaskRepository"/>
     </bean>
}}}

CdiBeanFactoryPostProcessor is fairly powerful. Just install it into Spring and then all of your CDI beans are available to Spring. No fuss. This works with [http://www.caucho.com/resin/candi/ Resin Candi], [http://seamframework.org/Weld JBoss Weld], and [Apache OpenWebBeans http://openwebbeans.apache.org/owb/index.html].

You can find CdiBeanFactoryPostProcessor at  [https://github.com/CDISource/cdisource/tree/master/spring CDI Spring Integration] which is part of the [https://github.com/CDISource CDI Source] efforts to advocate the use of CDI. Please review [https://github.com/CDISource/cdisource/blob/master/spring/src/main/java/org/cdisource/springintegration/CdiBeanFactoryPostProcessor.java CdiBeanFactoryPostProcessor] and the test cases for it and the [https://github.com/CDISource/examples/tree/master/spring-integration-example example roo based application that uses it]. We are seeking feedback.

== Bridging from the Spring World into CDI ==

We can also bridge from the Spring world into CDI. To do this we created two annotations: Spring and SpringLookup. SpringLookup is the simpler of the two. It works in all three open source CDI implementations [http://www.caucho.com/resin/candi/ Resin Candi], [http://seamframework.org/Weld JBoss Weld], and [Apache OpenWebBeans http://openwebbeans.apache.org/owb/index.html]. The Spring annotation is more complex (has more advanced features), and only works in [http://www.caucho.com/resin/candi/ Resin Candi], and [http://seamframework.org/Weld JBoss Weld].

(We plan on filing bug reports against OpenWebBeans and trying to work with that team to improve OpenWebBeans so that the Spring annotation can work there as well.)

*Examples of using Spring annotation*
{{{
package org.cdisource.springintegration;

import javax.inject.Inject;

public class CdiBeanThatHasSpringInjection {
	@Inject @Spring(name="fooBar") 
	FooSpringBean springBean;

	@Inject @Spring(name="fooBarnotActuallyThere", required=false)
	FooSpringBean notActuallyThere;
	
	
	@Inject @Spring(type=FooSpringBean2.class) 
	FooSpringBean2 injectByType;

	public void validate () {
		if (springBean==null) {
			throw new IllegalStateException("spring bean was null");
		}
		if (notActuallyThere!=null) {
			throw new IllegalStateException("notActuallyThere should be null");
		}
		if (injectByType==null) {
			throw new IllegalStateException("injectByType should be there");
		}

	}
}

}}}



The form 
*by name*
{{{
	@Inject @Spring(name="fooBar") 
	FooSpringBean springBean;

}}}

will look up the bean in Spring at the appropriate time given the appropriate name. The extension we wrote will create a [http://docs.jboss.org/cdi/api/latest/javax/enterprise/inject/spi/Bean.html Bean] that has a @Named qualifier when it sees this type of injection. OpenWebBeans rejects this named qualifier. This works in Weld and Resin Candi (4.0.17 and later).

The form 

{{{
	@Inject @Spring(name="fooBarnotActuallyThere", required=false)
	FooSpringBean notActuallyThere;

}}}

If there is a chance the bean will not be there, i.e., the injection is optional, you can specify a required=false. This means if we can't find the bean in Spring, don't throw an exception.
This works in Weld and Resin Candi (4.0.17 and later).


The form
 
*by type*
{{{
	@Inject @Spring(type=FooSpringBean2.class) 
	FooSpringBean2 injectByType;

}}}

The above form will look up the type in the Spring application context by type instead of by name. This works in Weld as long as FooSpringBean2 is a concrete class. In Resin Candi, FooSpringBean2 can be an interface or a concrete type. In order to write proper extensions, we believe that Weld should allow interfaces so that concrete types can be defined in Spring and injected into CDI correctly. Thus you could have a concreted implementation in Spring as follows:

{{{
	<bean name="fooBar3"  class="org.cdisource.springintegration.FooSpringBean2Impl"/>

}}}


The form
 
*by type by name*
{{{
	@Inject @Spring(name="foo2", type=FooSpringBean2.class) 
	FooSpringBean2 injectByType;

}}}

This is form will look up bean in the application context uses the name and the type. Spring throws an exemption if the types don't match. Again, this fails if the type is an interface if you are using Weld. 

Here is the exact weld exception when FooSpringBean2 is an interface: 

{{{
Exception 0 :
org.jboss.weld.exceptions.DefinitionException: WELD-001508 Cannot create an InjectionTarget from public abstract interface class org.cdisource.springintegration.FooSpringBean2 as it is an interface
	at org.jboss.weld.manager.SimpleInjectionTarget.<init>(SimpleInjectionTarget.java:71)
	at org.jboss.weld.manager.BeanManagerImpl.createInjectionTarget(BeanManagerImpl.java:1051)
	at org.cdisource.springintegration.SpringIntegrationExtention$SpringBean.<init>(SpringIntegrationExtention.java:93)
	at org.cdisource.springintegration.SpringIntegrationExtention.processInjectionTarget(SpringIntegrationExtention.java:48)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
	at java.lang.reflect.Method.invoke(Method.java:597)
}}}

We developing this injection, using Spring annotation was the ideal. Then we realized since the implementations did not all support looking up objects by interface types (Weld) and registering beans using a @Named literal that we would need something that just always worked. This is where the SpringLookup came into play. In our minds it is not ideal, the implementations should support the features in the Spring annotation. SpringLookup works in all three CDI containers. You use it as follows:


{{{
package org.cdisource.springintegration;

import javax.inject.Inject;

public class CdiBeanThatHasSpringLookupInjection {
	@Inject @SpringLookup("fooBar2")
	FooSpringBean springBean;

	@Inject @SpringLookup("fooBar2")
	FooSpringBean springBean2;

	
	public void validate () {
		if (springBean==null) {
			throw new IllegalStateException("spring bean was null");
		}
		if (springBean2==null) {
			throw new IllegalStateException("spring bean2 was null");
		}

	}
}

}}}

Using @SpringLookup never uses types. The best implementation to use Spring integration at this point in time is Candi 4.0.17 (a couple of weeks ago it was Weld as this @Spring and @SpringLookup did not work in Resin Candi 4.0.16).

We may still be running into concreted type issues with Weld even with @SpringLookup. We may have to create a proxy object to implement interfaces on the fly. It would be best if Weld just supported this.
